# JMH Benchmark Runner

This directory contains helper scripts to run JMH (Java Microbenchmark Harness) benchmarks correctly.

## Problem

The `maven-exec-plugin` does not properly load resources from the test classpath, causing JMH to fail with:
```
ERROR: Unable to find the resource: /META-INF/BenchmarkList
```

Even when using `-Dexec.classpathScope=test`, the plugin fails to find the `BenchmarkList` file generated by the JMH annotation processor at `target/test-classes/META-INF/BenchmarkList`.

## Solution

Use the provided helper scripts which run JMH with direct `java -cp` command, ensuring proper classpath configuration:

### Windows
```bash
run-jmh-benchmarks.bat                    # Run all benchmarks
run-jmh-benchmarks.bat FFT8              # Run specific benchmark
run-jmh-benchmarks.bat FFT8 -f 3 -wi 10  # With custom JMH options
```

### Linux/Mac
```bash
./run-jmh-benchmarks.sh                    # Run all benchmarks
./run-jmh-benchmarks.sh FFT8              # Run specific benchmark
./run-jmh-benchmarks.sh FFT8 -f 3 -wi 10  # With custom JMH options
```

## How It Works

The scripts:
1. Compile test classes: `mvn clean test-compile`
2. Generate JMH metadata via annotation processor â†’ `target/test-classes/META-INF/BenchmarkList`
3. Build classpath with:
   - `target/test-classes` (JMH generated benchmarks)
   - `target/classes` (production code)
   - JMH dependencies (jmh-core, jmh-generator-annprocess)
   - Project dependencies (SLF4J, Logback, etc.)
4. Run JMH directly: `java -cp <classpath> org.openjdk.jmh.Main <pattern> <options>`

## Available Benchmarks

- `FFTBaseProfilingBenchmark` - Profiling individual FFTBase operations
  - Twiddle factor calculation
  - Bit-reversal permutation
  - Butterfly operations
  - Array copying methods
  - Full FFT transform

- `FFTPerformanceBenchmark` - Comparing optimized vs base implementations
  - FFT8, FFT16, FFT32, FFT64, FFT128

## JMH Options

Common JMH options you can pass to the scripts:

- `-f <forks>` - Number of JVM forks (default: 3)
- `-wi <iterations>` - Warmup iterations (default: 5)
- `-i <iterations>` - Measurement iterations (default: 10)
- `-r <time>` - Time per iteration (default: 2s)
- `-w <time>` - Warmup time per iteration (default: 2s)
- `-t <threads>` - Number of threads (default: 1)

Example:
```bash
./run-jmh-benchmarks.sh FFTBaseProfiling -f 1 -wi 3 -i 5 -r 1s
```

## Benchmark Results

Benchmarks output detailed statistics including:
- **Average time per operation** (ns/op)
- **Confidence intervals** (99.9%)
- **Min/Max/Avg** values
- **Standard deviation**

Results help identify performance bottlenecks and verify optimization improvements.

## Technical Details

### JMH Annotation Processor Configuration

The pom.xml includes JMH annotation processor in the compiler plugin:

```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-compiler-plugin</artifactId>
    <configuration>
        <annotationProcessorPaths>
            <path>
                <groupId>org.openjdk.jmh</groupId>
                <artifactId>jmh-generator-annprocess</artifactId>
                <version>1.37</version>
            </path>
        </annotationProcessorPaths>
    </configuration>
</plugin>
```

During `mvn test-compile`, the annotation processor:
1. Scans test classes for JMH annotations (`@Benchmark`, `@State`, etc.)
2. Generates test harness classes in `target/generated-test-sources/test-annotations/`
3. Creates `target/test-classes/META-INF/BenchmarkList` with benchmark metadata

### Classpath Requirements

JMH requires these JARs on the classpath:
- `jmh-core-1.37.jar` - Core JMH runtime
- `jmh-generator-annprocess-1.37.jar` - Annotation processor
- `jopt-simple-5.0.4.jar` - Command-line parsing
- `commons-math3-3.6.1.jar` - Statistical analysis

The helper scripts automatically configure all required dependencies.

## See Also

- `JMH_BENCHMARKING_GUIDE.md` - Methodology and best practices
- `PERFORMANCE_OPTIMIZATION_STATUS.md` - Current optimization status
- `CLAUDE.md` - Full development guide
